<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation Â· iLQR.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">iLQR.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Trajectory-Optimization"><span>Trajectory Optimization</span></a></li><li><a class="tocitem" href="#Forward-Rollout"><span>Forward Rollout</span></a></li><li><a class="tocitem" href="#Backward-Pass"><span>Backward Pass</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aabouman/iLQR.jl/blob/master/docs/src/documentation.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="iLQR.jl-Documentation"><a class="docs-heading-anchor" href="#iLQR.jl-Documentation">iLQR.jl Documentation</a><a id="iLQR.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#iLQR.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#iLQR.jl-Documentation">iLQR.jl Documentation</a></li><ul><li><a href="#Index">Index</a></li><li><a href="#Trajectory-Optimization">Trajectory Optimization</a></li><li><a href="#Forward-Rollout">Forward Rollout</a></li><li><a href="#Backward-Pass">Backward Pass</a></li></ul><li><a href="../#iLQR.jl-Documentation">iLQR.jl Documentation</a></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#iLQR.backward_pass"><code>iLQR.backward_pass</code></a></li><li><a href="#iLQR.feedback_parameters"><code>iLQR.feedback_parameters</code></a></li><li><a href="#iLQR.final_cost_quadratization"><code>iLQR.final_cost_quadratization</code></a></li><li><a href="#iLQR.fit"><code>iLQR.fit</code></a></li><li><a href="#iLQR.forward_pass"><code>iLQR.forward_pass</code></a></li><li><a href="#iLQR.immediate_cost_quadratization"><code>iLQR.immediate_cost_quadratization</code></a></li><li><a href="#iLQR.linearize_dynamics"><code>iLQR.linearize_dynamics</code></a></li><li><a href="#iLQR.optimal_controller_param"><code>iLQR.optimal_controller_param</code></a></li><li><a href="#iLQR.step_back"><code>iLQR.step_back</code></a></li></ul><h2 id="Trajectory-Optimization"><a class="docs-heading-anchor" href="#Trajectory-Optimization">Trajectory Optimization</a><a id="Trajectory-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Optimization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="iLQR.fit" href="#iLQR.fit"><code>iLQR.fit</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>fit(x_init, u_init, dynamicsf, immediate_cost, final_cost; max_iter=100, tol=1e-6)</code></p><p>Perform iterativer LQR to compute optimal input and corresponding state trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>x_init::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>u_init::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li><li><code>immediate_cost::Function</code>: Cost after each step</li><li><code>final_cost::Function</code>: Cost after final step</li><li><code>max_iter::Int64=100</code>: Maximum number of forward/backward passes to make</li><li><code>tol::Float64=1e-6</code>: Specifies the tolerance at which to consider the input</li></ul><p>trajectory has converged</p><p>The <code>dynamicsf</code> steps the system forward, <span>$x_{i+1} = f(x_i, u_i)$</span>. The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> with the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the optimal trajectory <span>$(\bar{x}, \bar{u})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/forward_pass.jl#L94-L144">source</a></section></article><h2 id="Forward-Rollout"><a class="docs-heading-anchor" href="#Forward-Rollout">Forward Rollout</a><a id="Forward-Rollout-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Rollout" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="iLQR.forward_pass" href="#iLQR.forward_pass"><code>iLQR.forward_pass</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>forward_pass(x, u, ğ›¿ğ®á¶ á¶ s, ğŠs, prev_cost, dynamicsf, immediate_cost, final_cost)</code></p><p>Perform iterativer LQR to compute optimal input and corresponding state trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>u::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğ›¿ğ®á¶ á¶ s::AbstractMatrix{T}</code>: see output of <a href="#iLQR.backward_pass"><code>backward_pass(x, u, dynamicsf, immediate_cost, final_cost)</code></a></li><li><code>ğŠs::AbstractArray{T,3}</code>: see output of <a href="#iLQR.backward_pass"><code>backward_pass(x, u, dynamicsf, immediate_cost, final_cost)</code></a></li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li><li><code>immediate_cost::Function</code>: Cost after each step</li><li><code>final_cost::Function</code>: Cost after final step</li></ul><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector, u::AbstractVector)
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> with the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector, u::AbstractVector)
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector)
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the optimal trajectory <span>$(\bar{x}, \bar{u})$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/forward_pass.jl#L1-L53">source</a></section></article><h2 id="Backward-Pass"><a class="docs-heading-anchor" href="#Backward-Pass">Backward Pass</a><a id="Backward-Pass-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Pass" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="iLQR.backward_pass" href="#iLQR.backward_pass"><code>iLQR.backward_pass</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>backward_pass(x, u, dynamicsf, immediate_cost, final_cost)</code></p><p>Computes feedforward and feedback gains (<span>$\delta {\bf u}_i^{ff}$</span>, and <span>${\bf K}_i$</span>).</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>u::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li><li><code>immediate_cost::Function</code>: Cost after each step</li><li><code>final_cost::Function</code>: Cost after final step</li></ul><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> with the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the feedback parameters <span>$\delta {\bf u}_i^{ff}$</span>, and <span>${\bf K}_i$</span> for each time step <span>$i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L281-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.step_back" href="#iLQR.step_back"><code>iLQR.step_back</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>step_back(ğ€áµ¢, ğ‘áµ¢, ğªáµ¢, ğáµ¢, ğ áµ¢, ğ†áµ¢, ğ‡áµ¢, ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢, ğ‘ áµ¢â‚Šâ‚, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></p><p>Computes the rollback parameters <span>${\it s}_i$</span>, <span>${\bf s}_i$</span>, and <span>${\bf S}_i$</span> for the next step backward.</p><p><strong>Arguments</strong></p><ul><li><code>ğ€áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğ‘áµ¢::T</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğªáµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğ áµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ†áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ‡áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ›¿ğ®áµ¢á¶ á¶ ::AbstractVector{T}</code>: see output of <a href="#iLQR.feedback_parameters"><code>feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code></a></li><li><code>ğŠáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.feedback_parameters"><code>feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code></a></li><li><code>ğ‘ áµ¢â‚Šâ‚::T</code>: Rollback parameter</li><li><code>ğ¬áµ¢â‚Šâ‚::AbstractVector{T}</code>: Rollback parameter</li><li><code>ğ’áµ¢â‚Šâ‚::AbstractMatrix{T}</code>: Rollback parameter</li></ul><p>Returns the next-step-back&#39;s rollback parameters, <span>$({\it s}_i, {\bf s}_i, {\bf S}_i)$</span></p><p>Because <span>$ğ‡áµ¢$</span> can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L241-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.linearize_dynamics" href="#iLQR.linearize_dynamics"><code>iLQR.linearize_dynamics</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>linearize_dynamics(x, u, dynamicsf)</code></p><p>linearizes the function <code>dynamicsf</code> around the point <code>x</code> and <code>u</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: state at a specific step</li><li><code>u::AbstractVector{T}</code>: input at a specific step</li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li></ul><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>Returns <span>$(A, B)$</span>, which are matricies defined below.</p><p><span>$f(x_k, u_k) \approx A x_k + B u_k$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.immediate_cost_quadratization" href="#iLQR.immediate_cost_quadratization"><code>iLQR.immediate_cost_quadratization</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>immediate_cost_quadratization(x, u, immediate_cost)</code></p><p>Turns cost function into a quadratic at time step <span>$i$</span> around a point <span>$(xáµ¢, uáµ¢)$</span>. Details given in ETH slides.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: state at a specific step</li><li><code>u::AbstractVector{T}</code>: input at a specific step</li><li><code>immediate_cost::Function</code>: Cost after each step</li></ul><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> use the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>Returns the matricies <code>(ğ‘áµ¢, ğªáµ¢, ğ«áµ¢, ğáµ¢, ğáµ¢, ğ‘áµ¢)</code> defined as:</p><p><span>${\it q}_i = L(x_i, u_i)$</span>, <span>${\bf q}_i = \frac{\partial L(x_i, u_i)}{\partial x}$</span>, <span>${\bf r}_i = \frac{\partial L(x_i, u_i)}{\partial u}$</span>, <span>${\bf Q}_i = \frac{\partial^2 L(x_i, u_i)}{\partial x^2}$</span>, <span>${\bf P}_i = \frac{\partial^2 L(x_i, u_i)}{\partial x \partial u}$</span>, <span>${\bf R}_i = \frac{\partial^2 L(x_i, u_i)}{\partial u^2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L47-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.final_cost_quadratization" href="#iLQR.final_cost_quadratization"><code>iLQR.final_cost_quadratization</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>final_cost_quadratization(x, final_cost)</code></p><p>Turns final cost function into a quadratic at last time step, <code>n</code>, about point <code>(xâ‚™, uâ‚™)</code>. Details given in ETH slides.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: state at a specific step</li><li><code>final_cost::Function</code>: Cost after final step</li></ul><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the matricies <code>({\it q}_n, {\bf q}_n, {\it Q}_n)</code> defined as:</p><p><span>${\it q}_n = L(x_n, u_n)$</span>, <span>${\bf q}_n = \frac{\partial L(x_n, u_n)}{\partial x}$</span>, <span>${\bf Q}_n = \frac{\partial^2 L(x_n, u_n)}{\partial x^2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L116-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.optimal_controller_param" href="#iLQR.optimal_controller_param"><code>iLQR.optimal_controller_param</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></p><p>Computes optimal control parameters <code>(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code>, at time step <code>i</code>. These are used in computing feedforward and feedback gains.</p><p><strong>Arguments</strong></p><ul><li><code>ğ€áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğ«áµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğ‘áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğ¬áµ¢â‚Šâ‚::AbstractVector{T}</code>: Rollback parameter</li><li><code>ğ’áµ¢â‚Šâ‚::AbstractMatrix{T}</code>: Rollback parameter</li></ul><p>Returns the matricies <code>(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code> defined as:</p><p><span>${\bf g}_i = {\bf r}_i + {\bf B}_i^T {\bf s}_{i+1}$</span>, <span>${\bf G}_i = {\bf P}_i + {\bf B}_i^T {\bf S}_{i+1} {\bf A}_i$</span>, <span>${\bf H}_i = {\bf R}_i + {\bf B}_i^T {\bf S}_{i+1} {\bf B}_i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L161-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.feedback_parameters" href="#iLQR.feedback_parameters"><code>iLQR.feedback_parameters</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code></p><p>Computes feedforward and feedback gains, <span>$(\delta {\bf u}_i^{ff}, {\bf K}_i)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ğ áµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ†áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ‡áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li></ul><p>Returns the matricies <code>(ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢)</code> defined as:</p><p><span>$\delta {\bf u}_i^{ff} = - {\bf H}_i^{-1} {\bf g}_i$</span>, <span>${\bf K}_i = - {\bf H}_i^{-1} {\bf G}_i$</span></p><p>Because <span>${\bf H}_i$</span> can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/625365c08b8acfa13f23a2781b51e115501dabed/src/backward_pass.jl#L194-L211">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">Â« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 24 February 2021 00:26">Wednesday 24 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
