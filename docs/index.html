<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home Â· iLQR.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">iLQR.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Trajectory-Optimization"><span>Trajectory Optimization</span></a></li><li><a class="tocitem" href="#Forward-Rollout"><span>Forward Rollout</span></a></li><li><a class="tocitem" href="#Backward-Pass"><span>Backward Pass</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aabouman/iLQR.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="iLQR.jl-Documentation"><a class="docs-heading-anchor" href="#iLQR.jl-Documentation">iLQR.jl Documentation</a><a id="iLQR.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#iLQR.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#iLQR.jl-Documentation">iLQR.jl Documentation</a></li><ul><li><a href="#Index">Index</a></li><li><a href="#Trajectory-Optimization">Trajectory Optimization</a></li><li><a href="#Forward-Rollout">Forward Rollout</a></li><li><a href="#Backward-Pass">Backward Pass</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#iLQR.backward_pass"><code>iLQR.backward_pass</code></a></li><li><a href="#iLQR.feedback_parameters"><code>iLQR.feedback_parameters</code></a></li><li><a href="#iLQR.final_cost_quadratization"><code>iLQR.final_cost_quadratization</code></a></li><li><a href="#iLQR.fit"><code>iLQR.fit</code></a></li><li><a href="#iLQR.forward_pass"><code>iLQR.forward_pass</code></a></li><li><a href="#iLQR.immediate_cost_quadratization"><code>iLQR.immediate_cost_quadratization</code></a></li><li><a href="#iLQR.linearize_dynamics"><code>iLQR.linearize_dynamics</code></a></li><li><a href="#iLQR.optimal_controller_param"><code>iLQR.optimal_controller_param</code></a></li><li><a href="#iLQR.step_back"><code>iLQR.step_back</code></a></li></ul><h2 id="Trajectory-Optimization"><a class="docs-heading-anchor" href="#Trajectory-Optimization">Trajectory Optimization</a><a id="Trajectory-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Optimization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="iLQR.fit" href="#iLQR.fit"><code>iLQR.fit</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>fit(x_init, u_init, dynamicsf, immediate_cost, final_cost; max_iter=100, tol=1e-6)</code></p><p>Perform iterativer LQR to compute optimal input and corresponding state trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>x_init::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>u_init::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li><li><code>immediate_cost::Function</code>: Cost after each step</li><li><code>final_cost::Function</code>: Cost after final step</li><li><code>max_iter::Int64=100</code>: Maximum number of forward/backward passes to make</li><li><code>tol::Float64=1e-6</code>: Specifies the tolerance at which to consider the input</li></ul><p>trajectory has converged</p><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> with the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the optimal trajectory <span>$(xÌ…, uÌ…)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/forward_pass.jl#L91-L141">source</a></section></article><h2 id="Forward-Rollout"><a class="docs-heading-anchor" href="#Forward-Rollout">Forward Rollout</a><a id="Forward-Rollout-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Rollout" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="iLQR.forward_pass" href="#iLQR.forward_pass"><code>iLQR.forward_pass</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>forward_pass(x, u, ğ›¿ğ®á¶ á¶ s, ğŠs, prev_cost, dynamicsf, immediate_cost, final_cost)</code></p><p>Perform iterativer LQR to compute optimal input and corresponding state trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>u::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğ›¿ğ®á¶ á¶ s::AbstractMatrix{T}</code>: see output of <a href="#iLQR.backward_pass"><code>backward_pass(x, u, dynamicsf, immediate_cost, final_cost)</code></a></li><li><code>ğŠs::AbstractArray{T,3}</code>: see output of <a href="#iLQR.backward_pass"><code>backward_pass(x, u, dynamicsf, immediate_cost, final_cost)</code></a></li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li><li><code>immediate_cost::Function</code>: Cost after each step</li><li><code>final_cost::Function</code>: Cost after final step</li></ul><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> with the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the optimal trajectory <span>$(xÌ…, uÌ…)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/forward_pass.jl#L1-L50">source</a></section></article><h2 id="Backward-Pass"><a class="docs-heading-anchor" href="#Backward-Pass">Backward Pass</a><a id="Backward-Pass-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Pass" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="iLQR.backward_pass" href="#iLQR.backward_pass"><code>iLQR.backward_pass</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>backward_pass(x, u, dynamicsf, immediate_cost, final_cost)</code></p><p>Computes feedforward and feedback gains (<span>$ğ›¿ğ®áµ¢á¶ á¶ $</span> and <span>$ğŠáµ¢$</span>).</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>u::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li><li><code>immediate_cost::Function</code>: Cost after each step</li><li><code>final_cost::Function</code>: Cost after final step</li></ul><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> with the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the feedback parameters <span>$ğ›¿ğ®áµ¢á¶ á¶ áµ¢$</span>, and <span>$ğŠáµ¢$</span> for each time step <span>$i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L275-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.step_back" href="#iLQR.step_back"><code>iLQR.step_back</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>step_back(ğ€áµ¢, ğ‘áµ¢, ğªáµ¢, ğáµ¢, ğ áµ¢, ğ†áµ¢, ğ‡áµ¢, ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢, ğ‘ áµ¢â‚Šâ‚, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></p><p>Computes the rollback parameters <span>$ğ‘ áµ¢$</span>, <span>$ğ¬áµ¢$</span>, and <span>$ğ’áµ¢$</span> for the next step backward.</p><p><strong>Arguments</strong></p><ul><li><code>ğ€áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğ‘áµ¢::T</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğªáµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğ áµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ†áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ‡áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ›¿ğ®áµ¢á¶ á¶ ::AbstractVector{T}</code>: see output of <a href="#iLQR.feedback_parameters"><code>feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code></a></li><li><code>ğŠáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.feedback_parameters"><code>feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code></a></li><li><code>ğ‘ áµ¢â‚Šâ‚::T</code>: Rollback parameter</li><li><code>ğ¬áµ¢â‚Šâ‚::AbstractVector{T}</code>: Rollback parameter</li><li><code>ğ’áµ¢â‚Šâ‚::AbstractMatrix{T}</code>: Rollback parameter</li></ul><p>Returns the next-step-back&#39;s rollback parameters, <span>$(ğ‘ áµ¢, ğ¬áµ¢, ğ’áµ¢)$</span></p><p>Because <span>$ğ‡áµ¢$</span> can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L235-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.linearize_dynamics" href="#iLQR.linearize_dynamics"><code>iLQR.linearize_dynamics</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>linearize_dynamics(x, u, dynamicsf)</code></p><p>linearizes the function <code>dynamicsf</code> around the point <code>x</code> and <code>u</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: state at a specific step</li><li><code>u::AbstractVector{T}</code>: input at a specific step</li><li><code>dynamicsf::Function</code>: dynamic function, steps the system forward</li></ul><p>The <code>dynamicsf</code> steps the system forward (<span>$x_{i+1} = f(x_i, u_i)$</span>). The function expects input of the form:</p><pre><code class="language-julia">function dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T
    ...
    return xáµ¢â‚Šâ‚
end</code></pre><p>Returns <span>$(A, B)$</span>, which are matricies defined below.</p><p><span>$f(x_k, u_k) â‰ˆ A x_k + B u_k$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.immediate_cost_quadratization" href="#iLQR.immediate_cost_quadratization"><code>iLQR.immediate_cost_quadratization</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>immediate_cost_quadratization(x, u, immediate_cost)</code></p><p>Turns cost function into a quadratic at time step <span>$i$</span> around a point <span>$(xáµ¢, uáµ¢)$</span>. Details given in ETH slides.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: state at a specific step</li><li><code>u::AbstractVector{T}</code>: input at a specific step</li><li><code>immediate_cost::Function</code>: Cost after each step</li></ul><p>The <code>immediate_cost</code> function expect input of the form:</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(target_state - x.^2)  # for example
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important that the function <code>immediate_cost</code> be an explict function of both <code>x</code> and <code>u</code> (due to issues using <code>ForwardDiff</code> Package). If you want to make <code>immediate_cost</code> practically only dependent on <code>u</code> use the following</p><pre><code class="language-julia">function immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})
    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u
end</code></pre></div></div><p>Returns the matricies <code>(ğ‘áµ¢, ğªáµ¢, ğ«áµ¢, ğáµ¢, ğáµ¢, ğ‘áµ¢)</code> defined as:</p><p><span>$ğ‘áµ¢ = L(xáµ¢,uáµ¢)$</span>, <span>$ğªáµ¢ = \frac{âˆ‚L(xáµ¢,uáµ¢)}{âˆ‚x}$</span>, <span>$ğ«áµ¢ = \frac{âˆ‚L(xáµ¢,uáµ¢)}{âˆ‚u}$</span>, <span>$ğáµ¢ = \frac{âˆ‚^2 L(xáµ¢,uáµ¢)}{âˆ‚x^2}$</span>, <span>$ğáµ¢ = \frac{âˆ‚^2 L(xáµ¢,uáµ¢)}{âˆ‚x âˆ‚u}$</span>, <span>$ğ‘áµ¢ = \frac{âˆ‚^2 L(xáµ¢,uáµ¢)}{âˆ‚u^2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L47-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.final_cost_quadratization" href="#iLQR.final_cost_quadratization"><code>iLQR.final_cost_quadratization</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>final_cost_quadratization(x, final_cost)</code></p><p>Turns final cost function into a quadratic at last time step, <code>n</code>, about point <code>(xâ‚™, uâ‚™)</code>. Details given in ETH slides.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: state at a specific step</li><li><code>final_cost::Function</code>: Cost after final step</li></ul><p>The <code>final_cost</code> function expect input of the form:</p><pre><code class="language-julia">function final_cost(x::AbstractVector{T})
    return sum(target_state - x.^2)  # for example
end</code></pre><p>Returns the matricies <code>(ğ‘â‚™, ğªâ‚™, ğâ‚™)</code> defined as:</p><p><span>$ğ‘â‚™ = L(xâ‚™,uâ‚™)$</span>, <span>$ğªâ‚™ = \frac{âˆ‚L(xâ‚™,uâ‚™)}{âˆ‚x}$</span>, <span>$ğâ‚™ = \frac{âˆ‚^2 L(xâ‚™,uâ‚™)}{âˆ‚x^2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L113-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.optimal_controller_param" href="#iLQR.optimal_controller_param"><code>iLQR.optimal_controller_param</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></p><p>Computes optimal control parameters <code>(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code>, at time step <code>i</code>. These are used in computing feedforward and feedback gains.</p><p><strong>Arguments</strong></p><ul><li><code>ğ€áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.linearize_dynamics"><code>linearize_dynamics(x, u, dynamicsf)</code></a></li><li><code>ğ«áµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğáµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğ‘áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.immediate_cost_quadratization"><code>immediate_cost_quadratization(x, u, immediate_cost)</code></a></li><li><code>ğ¬áµ¢â‚Šâ‚::AbstractVector{T}</code>: Rollback parameter</li><li><code>ğ’áµ¢â‚Šâ‚::AbstractMatrix{T}</code>: Rollback parameter</li></ul><p>Returns the matricies <code>(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code> defined as:</p><p><span>$ğ áµ¢ = ğ«áµ¢ + ğáµ¢^T ğ¬áµ¢â‚Šâ‚$</span>, <span>$ğ†áµ¢ = ğáµ¢ + ğáµ¢^T ğ’áµ¢â‚Šâ‚ ğ€áµ¢$</span>, <span>$ğ‡áµ¢ = ğ‘áµ¢ + ğáµ¢^T ğ’áµ¢â‚Šâ‚ ğáµ¢$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L157-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="iLQR.feedback_parameters" href="#iLQR.feedback_parameters"><code>iLQR.feedback_parameters</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><code>feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)</code></p><p>Computes feedforward and feedback gains, <span>$(ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ğ áµ¢::AbstractVector{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ†áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li><li><code>ğ‡áµ¢::AbstractMatrix{T}</code>: see output of <a href="#iLQR.optimal_controller_param"><code>optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)</code></a></li></ul><p>Returns the matricies <code>(ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢)</code> defined as:</p><p><span>$ğ›¿ğ®áµ¢á¶ á¶  = - ğ‡áµ¢^{-1} ğ áµ¢$</span>, <span>$ğŠáµ¢ = - ğ‡áµ¢^{-1} ğ†áµ¢$</span></p><p>Because <span>$ğ‡áµ¢$</span> can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aabouman/iLQR.jl/blob/795a8d2a981771fbfed7d6a8139c7c74ea67bb2f/src/backward_pass.jl#L189-L205">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 February 2021 07:33">Tuesday 23 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
