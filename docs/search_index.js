var documenterSearchIndex = {"docs":
[{"location":"#iLQR.jl-Documentation","page":"Home","title":"iLQR.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Trajectory-Optimization","page":"Home","title":"Trajectory Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iLQR.fit","category":"page"},{"location":"#iLQR.fit","page":"Home","title":"iLQR.fit","text":"fit(x_init, u_init, dynamicsf, immediate_cost, final_cost; max_iter=100, tol=1e-6)\n\nPerform iterativer LQR to compute optimal input and corresponding state trajectory.\n\nArguments\n\nx_init::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nu_init::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\ndynamicsf::Function: dynamic function, steps the system forward\nimmediate_cost::Function: Cost after each step\nfinal_cost::Function: Cost after final step\nmax_iter::Int64=100: Maximum number of forward/backward passes to make\ntol::Float64=1e-6: Specifies the tolerance at which to consider the input\n\ntrajectory has converged\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T\n    ...\n    return xáµ¢â‚Šâ‚\nend\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u with the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the optimal trajectory (x u)\n\n\n\n\n\n","category":"function"},{"location":"#Forward-Rollout","page":"Home","title":"Forward Rollout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iLQR.forward_pass","category":"page"},{"location":"#iLQR.forward_pass","page":"Home","title":"iLQR.forward_pass","text":"forward_pass(x, u, ğ›¿ğ®á¶ á¶ s, ğŠs, prev_cost, dynamicsf, immediate_cost, final_cost)\n\nPerform iterativer LQR to compute optimal input and corresponding state trajectory.\n\nArguments\n\nx::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nu::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nğ›¿ğ®á¶ á¶ s::AbstractMatrix{T}: see output of backward_pass(x, u, dynamicsf, immediate_cost, final_cost)\nğŠs::AbstractArray{T,3}: see output of backward_pass(x, u, dynamicsf, immediate_cost, final_cost)\ndynamicsf::Function: dynamic function, steps the system forward\nimmediate_cost::Function: Cost after each step\nfinal_cost::Function: Cost after final step\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T\n    ...\n    return xáµ¢â‚Šâ‚\nend\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u with the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the optimal trajectory (x u)\n\n\n\n\n\n","category":"function"},{"location":"#Backward-Pass","page":"Home","title":"Backward Pass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iLQR.backward_pass","category":"page"},{"location":"#iLQR.backward_pass","page":"Home","title":"iLQR.backward_pass","text":"backward_pass(x, u, dynamicsf, immediate_cost, final_cost)\n\nComputes feedforward and feedback gains (ğ›¿ğ®áµ¢á¶ á¶  and ğŠáµ¢).\n\nArguments\n\nx::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nu::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\ndynamicsf::Function: dynamic function, steps the system forward\nimmediate_cost::Function: Cost after each step\nfinal_cost::Function: Cost after final step\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T\n    ...\n    return xáµ¢â‚Šâ‚\nend\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u with the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the feedback parameters ğ›¿ğ®áµ¢á¶ á¶ áµ¢, and ğŠáµ¢ for each time step i\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.step_back","category":"page"},{"location":"#iLQR.step_back","page":"Home","title":"iLQR.step_back","text":"step_back(ğ€áµ¢, ğ‘áµ¢, ğªáµ¢, ğáµ¢, ğ áµ¢, ğ†áµ¢, ğ‡áµ¢, ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢, ğ‘ áµ¢â‚Šâ‚, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\n\nComputes the rollback parameters ğ‘ áµ¢, ğ¬áµ¢, and ğ’áµ¢ for the next step backward.\n\nArguments\n\nğ€áµ¢::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nğáµ¢::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nğ‘áµ¢::T: see output of immediate_cost_quadratization(x, u, immediate_cost)\nğªáµ¢::AbstractVector{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\nğáµ¢::AbstractMatrix{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\nğ áµ¢::AbstractVector{T}: see output of optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\nğ†áµ¢::AbstractMatrix{T}: see output of optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\nğ‡áµ¢::AbstractMatrix{T}: see output of optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\nğ›¿ğ®áµ¢á¶ á¶ ::AbstractVector{T}: see output of feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)\nğŠáµ¢::AbstractMatrix{T}: see output of feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)\nğ‘ áµ¢â‚Šâ‚::T: Rollback parameter\nğ¬áµ¢â‚Šâ‚::AbstractVector{T}: Rollback parameter\nğ’áµ¢â‚Šâ‚::AbstractMatrix{T}: Rollback parameter\n\nReturns the next-step-back's rollback parameters, (ğ‘ áµ¢ ğ¬áµ¢ ğ’áµ¢)\n\nBecause ğ‡áµ¢ can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.linearize_dynamics","category":"page"},{"location":"#iLQR.linearize_dynamics","page":"Home","title":"iLQR.linearize_dynamics","text":"linearize_dynamics(x, u, dynamicsf)\n\nlinearizes the function dynamicsf around the point x and u.\n\nArguments\n\nx::AbstractVector{T}: state at a specific step\nu::AbstractVector{T}: input at a specific step\ndynamicsf::Function: dynamic function, steps the system forward\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xáµ¢::AbstractVector{T}, uáµ¢::AbstractVector{T}) where T\n    ...\n    return xáµ¢â‚Šâ‚\nend\n\nReturns (A B), which are matricies defined below.\n\nf(x_k u_k)  A x_k + B u_k\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.immediate_cost_quadratization","category":"page"},{"location":"#iLQR.immediate_cost_quadratization","page":"Home","title":"iLQR.immediate_cost_quadratization","text":"immediate_cost_quadratization(x, u, immediate_cost)\n\nTurns cost function into a quadratic at time step i around a point (xáµ¢ uáµ¢). Details given in ETH slides.\n\nArguments\n\nx::AbstractVector{T}: state at a specific step\nu::AbstractVector{T}: input at a specific step\nimmediate_cost::Function: Cost after each step\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u use the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nReturns the matricies (ğ‘áµ¢, ğªáµ¢, ğ«áµ¢, ğáµ¢, ğáµ¢, ğ‘áµ¢) defined as:\n\nğ‘áµ¢ = L(xáµ¢uáµ¢), ğªáµ¢ = fracL(xáµ¢uáµ¢)x, ğ«áµ¢ = fracL(xáµ¢uáµ¢)u, ğáµ¢ = frac^2 L(xáµ¢uáµ¢)x^2, ğáµ¢ = frac^2 L(xáµ¢uáµ¢)x u, ğ‘áµ¢ = frac^2 L(xáµ¢uáµ¢)u^2\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.final_cost_quadratization","category":"page"},{"location":"#iLQR.final_cost_quadratization","page":"Home","title":"iLQR.final_cost_quadratization","text":"final_cost_quadratization(x, final_cost)\n\nTurns final cost function into a quadratic at last time step, n, about point (xâ‚™, uâ‚™). Details given in ETH slides.\n\nArguments\n\nx::AbstractVector{T}: state at a specific step\nfinal_cost::Function: Cost after final step\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the matricies (ğ‘â‚™, ğªâ‚™, ğâ‚™) defined as:\n\nğ‘â‚™ = L(xâ‚™uâ‚™), ğªâ‚™ = fracL(xâ‚™uâ‚™)x, ğâ‚™ = frac^2 L(xâ‚™uâ‚™)x^2\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.optimal_controller_param","category":"page"},{"location":"#iLQR.optimal_controller_param","page":"Home","title":"iLQR.optimal_controller_param","text":"optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\n\nComputes optimal control parameters (ğ áµ¢, ğ†áµ¢, ğ‡áµ¢), at time step i. These are used in computing feedforward and feedback gains.\n\nArguments\n\nğ€áµ¢::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nğáµ¢::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nğ«áµ¢::AbstractVector{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\nğáµ¢::AbstractMatrix{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\nğ‘áµ¢::AbstractMatrix{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\nğ¬áµ¢â‚Šâ‚::AbstractVector{T}: Rollback parameter\nğ’áµ¢â‚Šâ‚::AbstractMatrix{T}: Rollback parameter\n\nReturns the matricies (ğ áµ¢, ğ†áµ¢, ğ‡áµ¢) defined as:\n\nğ áµ¢ = ğ«áµ¢ + ğáµ¢^T ğ¬áµ¢â‚, ğ†áµ¢ = ğáµ¢ + ğáµ¢^T ğ’áµ¢â‚ ğ€áµ¢, ğ‡áµ¢ = ğ‘áµ¢ + ğáµ¢^T ğ’áµ¢â‚ ğáµ¢\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.feedback_parameters","category":"page"},{"location":"#iLQR.feedback_parameters","page":"Home","title":"iLQR.feedback_parameters","text":"feedback_parameters(ğ áµ¢, ğ†áµ¢, ğ‡áµ¢)\n\nComputes feedforward and feedback gains, (ğ›¿ğ®áµ¢á¶ á¶  ğŠáµ¢).\n\nArguments\n\nğ áµ¢::AbstractVector{T}: see output of optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\nğ†áµ¢::AbstractMatrix{T}: see output of optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\nğ‡áµ¢::AbstractMatrix{T}: see output of optimal_controller_param(ğ€áµ¢, ğáµ¢, ğ«áµ¢, ğáµ¢, ğ‘áµ¢, ğ¬áµ¢â‚Šâ‚, ğ’áµ¢â‚Šâ‚)\n\nReturns the matricies (ğ›¿ğ®áµ¢á¶ á¶ , ğŠáµ¢) defined as:\n\nğ›¿ğ®áµ¢á¶ á¶  = - ğ‡áµ¢^-1 ğ áµ¢, ğŠáµ¢ = - ğ‡áµ¢^-1 ğ†áµ¢\n\nBecause ğ‡áµ¢ can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.\n\n\n\n\n\n","category":"function"}]
}
