var documenterSearchIndex = {"docs":
[{"location":"#iLQR.jl-Documentation","page":"Home","title":"iLQR.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Trajectory-Optimization","page":"Home","title":"Trajectory Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iLQR.fit","category":"page"},{"location":"#iLQR.fit","page":"Home","title":"iLQR.fit","text":"fit(x_init, u_init, dynamicsf, immediate_cost, final_cost; max_iter=100, tol=1e-6)\n\nPerform iterativer LQR to compute optimal input and corresponding state trajectory.\n\nArguments\n\nx_init::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nu_init::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\ndynamicsf::Function: dynamic function, steps the system forward\nimmediate_cost::Function: Cost after each step\nfinal_cost::Function: Cost after final step\nmax_iter::Int64=100: Maximum number of forward/backward passes to make\ntol::Float64=1e-6: Specifies the tolerance at which to consider the input\n\ntrajectory has converged\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xᵢ::AbstractVector{T}, uᵢ::AbstractVector{T}) where T\n    ...\n    return xᵢ₊₁\nend\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u with the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the optimal trajectory (x u)\n\n\n\n\n\n","category":"function"},{"location":"#Forward-Rollout","page":"Home","title":"Forward Rollout","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iLQR.forward_pass","category":"page"},{"location":"#iLQR.forward_pass","page":"Home","title":"iLQR.forward_pass","text":"forward_pass(x, u, 𝛿𝐮ᶠᶠs, 𝐊s, prev_cost, dynamicsf, immediate_cost, final_cost)\n\nPerform iterativer LQR to compute optimal input and corresponding state trajectory.\n\nArguments\n\nx::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nu::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\n𝛿𝐮ᶠᶠs::AbstractMatrix{T}: see output of backward_pass(x, u, dynamicsf, immediate_cost, final_cost)\n𝐊s::AbstractArray{T,3}: see output of backward_pass(x, u, dynamicsf, immediate_cost, final_cost)\ndynamicsf::Function: dynamic function, steps the system forward\nimmediate_cost::Function: Cost after each step\nfinal_cost::Function: Cost after final step\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xᵢ::AbstractVector{T}, uᵢ::AbstractVector{T}) where T\n    ...\n    return xᵢ₊₁\nend\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u with the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the optimal trajectory (x u)\n\n\n\n\n\n","category":"function"},{"location":"#Backward-Pass","page":"Home","title":"Backward Pass","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"iLQR.backward_pass","category":"page"},{"location":"#iLQR.backward_pass","page":"Home","title":"iLQR.backward_pass","text":"backward_pass(x, u, dynamicsf, immediate_cost, final_cost)\n\nComputes feedforward and feedback gains (𝛿𝐮ᵢᶠᶠ and 𝐊ᵢ).\n\nArguments\n\nx::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\nu::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\ndynamicsf::Function: dynamic function, steps the system forward\nimmediate_cost::Function: Cost after each step\nfinal_cost::Function: Cost after final step\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xᵢ::AbstractVector{T}, uᵢ::AbstractVector{T}) where T\n    ...\n    return xᵢ₊₁\nend\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u with the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the feedback parameters 𝛿𝐮ᵢᶠᶠᵢ, and 𝐊ᵢ for each time step i\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.step_back","category":"page"},{"location":"#iLQR.step_back","page":"Home","title":"iLQR.step_back","text":"step_back(𝐀ᵢ, 𝑞ᵢ, 𝐪ᵢ, 𝐐ᵢ, 𝐠ᵢ, 𝐆ᵢ, 𝐇ᵢ, 𝛿𝐮ᵢᶠᶠ, 𝐊ᵢ, 𝑠ᵢ₊₁, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n\nComputes the rollback parameters 𝑠ᵢ, 𝐬ᵢ, and 𝐒ᵢ for the next step backward.\n\nArguments\n\n𝐀ᵢ::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\n𝐁ᵢ::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\n𝑞ᵢ::T: see output of immediate_cost_quadratization(x, u, immediate_cost)\n𝐪ᵢ::AbstractVector{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\n𝐐ᵢ::AbstractMatrix{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\n𝐠ᵢ::AbstractVector{T}: see output of optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n𝐆ᵢ::AbstractMatrix{T}: see output of optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n𝐇ᵢ::AbstractMatrix{T}: see output of optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n𝛿𝐮ᵢᶠᶠ::AbstractVector{T}: see output of feedback_parameters(𝐠ᵢ, 𝐆ᵢ, 𝐇ᵢ)\n𝐊ᵢ::AbstractMatrix{T}: see output of feedback_parameters(𝐠ᵢ, 𝐆ᵢ, 𝐇ᵢ)\n𝑠ᵢ₊₁::T: Rollback parameter\n𝐬ᵢ₊₁::AbstractVector{T}: Rollback parameter\n𝐒ᵢ₊₁::AbstractMatrix{T}: Rollback parameter\n\nReturns the next-step-back's rollback parameters, (𝑠ᵢ 𝐬ᵢ 𝐒ᵢ)\n\nBecause 𝐇ᵢ can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.linearize_dynamics","category":"page"},{"location":"#iLQR.linearize_dynamics","page":"Home","title":"iLQR.linearize_dynamics","text":"linearize_dynamics(x, u, dynamicsf)\n\nlinearizes the function dynamicsf around the point x and u.\n\nArguments\n\nx::AbstractVector{T}: state at a specific step\nu::AbstractVector{T}: input at a specific step\ndynamicsf::Function: dynamic function, steps the system forward\n\nThe dynamicsf steps the system forward (x_i+1 = f(x_i u_i)). The function expects input of the form:\n\nfunction dynamics(xᵢ::AbstractVector{T}, uᵢ::AbstractVector{T}) where T\n    ...\n    return xᵢ₊₁\nend\n\nReturns (A B), which are matricies defined below.\n\nf(x_k u_k)  A x_k + B u_k\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.immediate_cost_quadratization","category":"page"},{"location":"#iLQR.immediate_cost_quadratization","page":"Home","title":"iLQR.immediate_cost_quadratization","text":"immediate_cost_quadratization(x, u, immediate_cost)\n\nTurns cost function into a quadratic at time step i around a point (xᵢ uᵢ). Details given in ETH slides.\n\nArguments\n\nx::AbstractVector{T}: state at a specific step\nu::AbstractVector{T}: input at a specific step\nimmediate_cost::Function: Cost after each step\n\nThe immediate_cost function expect input of the form:\n\nfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(target_state - x.^2)  # for example\nend\n\nnote: Note\nIt is important that the function immediate_cost be an explict function of both x and u (due to issues using ForwardDiff Package). If you want to make immediate_cost practically only dependent on u use the followingfunction immediate_cost(x::AbstractVector{T}, u::AbstractVector{T})\n    return sum(u.^2) + sum(x) * 0.0  # Only dependent on u\nend\n\nReturns the matricies (𝑞ᵢ, 𝐪ᵢ, 𝐫ᵢ, 𝐐ᵢ, 𝐏ᵢ, 𝐑ᵢ) defined as:\n\n𝑞ᵢ = L(xᵢuᵢ), 𝐪ᵢ = fracL(xᵢuᵢ)x, 𝐫ᵢ = fracL(xᵢuᵢ)u, 𝐐ᵢ = frac^2 L(xᵢuᵢ)x^2, 𝐏ᵢ = frac^2 L(xᵢuᵢ)x u, 𝐑ᵢ = frac^2 L(xᵢuᵢ)u^2\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.final_cost_quadratization","category":"page"},{"location":"#iLQR.final_cost_quadratization","page":"Home","title":"iLQR.final_cost_quadratization","text":"final_cost_quadratization(x, final_cost)\n\nTurns final cost function into a quadratic at last time step, n, about point (xₙ, uₙ). Details given in ETH slides.\n\nArguments\n\nx::AbstractVector{T}: state at a specific step\nfinal_cost::Function: Cost after final step\n\nThe final_cost function expect input of the form:\n\nfunction final_cost(x::AbstractVector{T})\n    return sum(target_state - x.^2)  # for example\nend\n\nReturns the matricies (𝑞ₙ, 𝐪ₙ, 𝐐ₙ) defined as:\n\n𝑞ₙ = L(xₙuₙ), 𝐪ₙ = fracL(xₙuₙ)x, 𝐐ₙ = frac^2 L(xₙuₙ)x^2\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.optimal_controller_param","category":"page"},{"location":"#iLQR.optimal_controller_param","page":"Home","title":"iLQR.optimal_controller_param","text":"optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n\nComputes optimal control parameters (𝐠ᵢ, 𝐆ᵢ, 𝐇ᵢ), at time step i. These are used in computing feedforward and feedback gains.\n\nArguments\n\n𝐀ᵢ::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\n𝐁ᵢ::AbstractMatrix{T}: see output of linearize_dynamics(x, u, dynamicsf)\n𝐫ᵢ::AbstractVector{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\n𝐏ᵢ::AbstractMatrix{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\n𝐑ᵢ::AbstractMatrix{T}: see output of immediate_cost_quadratization(x, u, immediate_cost)\n𝐬ᵢ₊₁::AbstractVector{T}: Rollback parameter\n𝐒ᵢ₊₁::AbstractMatrix{T}: Rollback parameter\n\nReturns the matricies (𝐠ᵢ, 𝐆ᵢ, 𝐇ᵢ) defined as:\n\n𝐠ᵢ = 𝐫ᵢ + 𝐁ᵢ^T 𝐬ᵢ₁, 𝐆ᵢ = 𝐏ᵢ + 𝐁ᵢ^T 𝐒ᵢ₁ 𝐀ᵢ, 𝐇ᵢ = 𝐑ᵢ + 𝐁ᵢ^T 𝐒ᵢ₁ 𝐁ᵢ\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"iLQR.feedback_parameters","category":"page"},{"location":"#iLQR.feedback_parameters","page":"Home","title":"iLQR.feedback_parameters","text":"feedback_parameters(𝐠ᵢ, 𝐆ᵢ, 𝐇ᵢ)\n\nComputes feedforward and feedback gains, (𝛿𝐮ᵢᶠᶠ 𝐊ᵢ).\n\nArguments\n\n𝐠ᵢ::AbstractVector{T}: see output of optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n𝐆ᵢ::AbstractMatrix{T}: see output of optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n𝐇ᵢ::AbstractMatrix{T}: see output of optimal_controller_param(𝐀ᵢ, 𝐁ᵢ, 𝐫ᵢ, 𝐏ᵢ, 𝐑ᵢ, 𝐬ᵢ₊₁, 𝐒ᵢ₊₁)\n\nReturns the matricies (𝛿𝐮ᵢᶠᶠ, 𝐊ᵢ) defined as:\n\n𝛿𝐮ᵢᶠᶠ = - 𝐇ᵢ^-1 𝐠ᵢ, 𝐊ᵢ = - 𝐇ᵢ^-1 𝐆ᵢ\n\nBecause 𝐇ᵢ can be poorly conditioned, the regularized inverse of the matrix is computed instead of the true inverse.\n\n\n\n\n\n","category":"function"}]
}
